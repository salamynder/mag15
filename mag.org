* Eingrenzung des Themas
Diese Arbeit beschreibt und evaluiert eine mit »Grammatical Framework« (GF) implementierte sogenannte Ressourcen-Grammatik für das Chinesische. Eine Hinführung zum Thema GF sowie in die Nutzung der »Resource Grammar Library« (RGL) von GF wird den Evaluationsprozess nachverfolgbar machen. 
* Grammatiken programmieren mit GF
** Überblick
GF ist eine Programmiersprache zum Programmieren multilingualer Applikationen. Dass wir beim Übersetzungsvorgang einen multilingualen Ansatz benötigen, liegt auf der Hand, aber wie ist er realisiert in GF? GF zwischen konkreten Grammatiken (für bestimmte Übersetzungszielsprachen) und abstrakten Grammatiken (semantische oder syntaktische Interlingua). Konkrete Grammatiken werden für die Übersetzung in und aus bestimmten Sprachen erstellt; abstrakte Grammatiken dienen als Dreh- und Angelpunkt für (mindestens eine) konkrete Grammatiken{??}, indem diese eine semantische Interlingua bereitstellen. Ein Beispiel[fn:: Zuerst verwendet in \cite{ranta_gf-lrec-2010.pdf_2010} und sodann auch in \cite{_grammatical_2014}.] soll dies Verdeutlichen.

Zunächst skizzieren wir beispielhaft die oben beschriebene Interaktion zwischen abstrakten und konkreten Grammatiken.

*** Beispiel: Marie und John (1)
Die folgenden 3 GF-Module (Zero.gf, ZeroGer.gf, ZeroChi.gf in Abbildung \ref{mj1}) ermöglichen die Übersetzung beschriebener semantischer Einheiten vom Chinesischen ins Deutsche und umgekehrt:

#+name: mj1
#+CAPTION[Hello-GF]: Ein erster Einblick
#+begin_src bash

abstract Zero = {            concrete ZeroGer of Zero = {    concrete ZeroChi of Zero = { 
  cat                          lincat                          lincat                      
    S; NP; VP; V2;               S, NP, VP, V2 = Str;             S, NP, VP, V2 = Str;
  fun                          lin                             lin
    Pred : NP -> VP -> S;        Pred np vp = np ++ vp;           Pred np vp = np ++ vp;
    Compl : V2 -> NP -> VP;      Compl v2 np = v2 ++ np;          Compl v2 np = v2 ++ np;
    John, Mary : NP;             John = "Johann";                 John = "约翰";
    Love : V2;                   Mary = "Marie";                  Mary = "玛丽";
                                 Love = "liebt";                  Love = "爱";
}                            }                               }
                                                           
#+end_src

Sind diese drei Dateien vorbereitet, so können wir mit der GF-Shell arbeiten:

#+BEGIN_SRC bash
Languages: ZeroChi ZeroGer
Zero> parse -lang=ZeroChi "约翰 爱 玛丽"
Pred John (Compl Love Mary)
#+END_SRC

#+BEGIN_SRC bash
Zero> parse -lang=ZeroChi "约翰 爱 玛丽" | linearize -lang=ZeroGer
Johann liebt Marie
#+END_SRC

Zeile 1 zeigt die geladenen konkreten Grammatiken hinter der Label »Languages« an, die wir für eine Übersetzung heranziehen können. Zeile 2 enhält nach dem sogenannten Prompt oder Eingabeaufforderung am Anfang der Zeile (bestehend aus dem Namen der abstrakten Grammatik sowie »>«) die Anweisung für die Übersetzung, die sich folgerdermaßen unterteilt:

1. Eine Zeichenkette oder auch String (»约翰 爱 玛丽«) wird mittels des Kommandos »parse« eingelesen und verarbeitet.
2. Das Ergebnis der Verarbeitung wird durch den Operator »Vertikale Linie«, »|«, auch Pipe genannt, weitergeleitet …
3. … an das Kommando »linearize«


#+ATTR_LATEX: :options [itemsep=0pt]

simple Übersetzungsgrammatik mittels dreier GF-Module: Zero.gf, ZeroGer.gf, ZeroChi.gf
- Agreement is indeed assumed to be one of the strengths of GF, so it is important to understand how it works! And not difficult, if you start with simple examples. Yours is simple enough, so let's look at it.

I have put a minimal grammar in

  http://cloud.grammaticalframework.org/gfse/

entitled "Eyes", and you can play with it and extend it as you want. The main idea is that

- NP has Number as inherent feature (field in a record)
- N has Number as variable feature (argument in a table)

Determiners set the Number of an NP, and select the number of N. Thus "this" sets an NP to be Sg, and selects the Sg form of the N.

With "your", you must think in a bit tricky way. There are, so to say, two variants of it: YourSg and YourPl. Many languages actually differentiate them (e.g. French and German) but in English they are the same string. But otherwise they work like This and These.

You should read the GF book chapter 3 for more details, and then 4 and 9 for even more details. If you don't have the book, the book slides may give enough information.


** 
** 
** 
** 
* Evaluation der chinesischen Ressourcen Grammatik
** eng_chi2.txt:
*** 把 nur auf Dinge beziehbar?
- mkUtt (mkVP answer_V2S he_NP (mkS (mkCl she_NP sleep_V))) 
to answer to him that she sleeps
把他回答说她睡 BAD 回答他说她睡了
- mkUtt (mkVP (mkVPSlash paint_V2A (mkAP black_A)))
to paint itself black
画自己黑 BAD 把它自己画黑


** 
** 
* End
\printbibliography
* zotero							   :noexport:
# Local Variables:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# End:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# Ende:
* Header							    :ARCHIVE: :noexport:
#+TODO: TODO | WAITING DONE
#+LATEX_CLASS: cn-article
#+TITLE: Grundlagen maschineller multilingualer Übersetzung anhand des »Grammatical Framework« (GF) mit besonderer Berücksichtigung des Hoch-Chinesischen
#+AUTHOR: René Tobner
#+LANGUAGE: de-de
#+OPTIONS: H:4 skip:nil ^:nil timestamp:nil

#+LATEX_HEADER: \usepackage[ngerman]{babel}
#+LATEX_HEADER: \addbibresource{mag.bib}

#+LATEX_HEADER: % Make commands for the quotes
#+LATEX_HEADER: \newcommand{\mq}[1]{\enquote{#1}}
#+LATEX_HEADER: \newcommand*{\openquote}{\tikz[remember picture,overlay,xshift=-15pt,yshift=-10pt]
#+LATEX_HEADER:      \node (OQ) {\quotefont\fontsize{60}{60}\selectfont``};\kern0pt}
#+LATEX_HEADER: \newcommand*{\closequote}{\tikz[remember picture,overlay,xshift=15pt,yshift=10pt]
#+LATEX_HEADER:      \node (CQ) {\quotefont\fontsize{60}{60}\selectfont''};}
#+LATEX_HEADER: % select a colour for the shading
#+LATEX_HEADER: %\definecolor{shadecolor}{named}{gray}
#+LATEX_HEADER: % wrap everything in its own environment
#+LATEX_HEADER: \newenvironment{shadequote}%
#+LATEX_HEADER: {\begin{quote}\openquote}
#+LATEX_HEADER: {\hfill\closequote\end{quote}}
#+LATEX_HEADER: 
#+LATEX_HEADER: \newcommand{\xelatex}{\XeLaTeX\xspace} 
#+LATEX_HEADER: \newcommand{\latex}{\LaTeX\xspace}
#+LATEX_HEADER: 
#+LATEX_HEADER: %\newglossary[<log-ext>]{<name>}{<in-ext>}{<out-ext>}{<title>}[<counter>]
#+LATEX_HEADER: %\newglossary[alg]{atom}{aot}{atn}{Zeichen-Ebene}
#+LATEX_HEADER: %\newglossary[slg]{sets}{sot}{stn}{Zeichensatz-Ebene}
#+LATEX_HEADER: %\newglossary[ulg]{unicode-specific}{uot}{utn}{Unicode-Spezifisches}
#+LATEX_HEADER: 
#+LATEX_HEADER: %\makeglossaries
#+LATEX_HEADER: %\loadglsentries{glossar}
#+LATEX_HEADER: % For BIBER
#+LATEX_HEADER: \DeclareSourcemap{
#+LATEX_HEADER:  \maps[datatype=bibtex, overwrite]{
#+LATEX_HEADER:    \map{
#+LATEX_HEADER:      \step[fieldset=language, null] % exclude bib language field from printing
#+LATEX_HEADER:      \step[fieldset=month, null] 
#+LATEX_HEADER:    }
#+LATEX_HEADER:  }
#+LATEX_HEADER: }
#+LATEX_HEADER: \newcommand\mpDr[1]{\marginpar{\fontspec[Scale=0.7]{Droid Sans}#1}}
#+LATEX_HEADER: \newcommand\zb{z. B.}
#+LATEX_HEADER: \newcommand\di{d. I.}
#+LATEX_HEADER: 
#+LATEX_HEADER: %Elision in citation ... took so long to find this, don't know if this the best way :(
#+LATEX_HEADER: \newcommand*\elide{\textup{[\dots]}\xspace}
#+LATEX_HEADER: % Using "[" and "]" in the pre/postnote of citation seems a big problem, therefore new command for [sic]
#+LATEX_HEADER: \newcommand*\sic{\textup{[sic]}\xspace}
#+LATEX_HEADER: 
#+LATEX_HEADER: \hyphenation{dash}
#+LATEX_HEADER: \newfontfamily\dejavus[Mapping=tex-ansi]{DejaVu Sans}
#+LATEX_HEADER: \newfontfamily\scpro[Mapping=tex-ansi]{Source Code Pro}
#+LATEX_HEADER: \newfontfamily\linmono[Mapping=tex-ansi]{Linux Libertine Mono}
#+LATEX_HEADER: \newfontfamily\linansi[Mapping=tex-ansi]{Linux Libertine}

# Local Variables:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# End:
\pagenumbering{roman}
\listoffigures
\listoftables
