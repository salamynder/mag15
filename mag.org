* Eingrenzung des Themas
Diese Arbeit beschreibt und evaluiert eine mit »Grammatical Framework« (GF) implementierte sogenannte Ressourcen-Grammatik für das Chinesische. Eine Hinführung zum Thema GF sowie in die Nutzung der »Resource Grammar Library« (RGL) von GF wird den Evaluationsprozess nachverfolgbar machen. 
- \cite{thompson_type_1991}
* Grammatiken programmieren mit GF
** Überblick
GF ist eine Programmiersprache zum Programmieren multilingualer Applikationsgrammatiken.[fn:: Eine Applikation ist eine Anwendung(-software). TODO: Diesen Begriff genauer klären, wie ist eine application grammar in GF zu verstehen? cf. gf-book, Einleitung] Dass wir beim Übersetzungsvorgang einen multilingualen Ansatz benötigen, liegt auf der Hand, aber wie ist er realisiert in GF? GF zwischen konkreten Grammatiken (für bestimmte Übersetzungszielsprachen) und abstrakten Grammatiken (semantische oder syntaktische Interlingua). Konkrete Grammatiken werden für die Übersetzung in und aus bestimmten Sprachen erstellt; abstrakte Grammatiken dienen als Dreh- und Angelpunkt für (mindestens eine) konkrete Grammatiken{??}, indem diese eine semantische Interlingua bereitstellen.

Die nun verwendeten Beispiel-Dateien befinden sich (genau so wie dieser Text) in einem öffentlich zugänglichen Git-Repositorium.[fn:: https://github.com/salamynder/mag15 . Siehe auch zur Installation von GF auf verschiedenen Systemen: http://www.grammaticalframework.org/download/index.html . GF_LIB_PATH unter Windows setzen: http://www.grammaticalframework.org/~inari/gf-windows.html . Die von mir verwendeten GF-Version ist TODO.] 

*** Beispiel: Marie und John (1)
Zunächst skizzieren wir beispielhaft[fn:: Zuerst verwendet in \cite{ranta_gf-lrec-2010.pdf_2010} und sodann auch in \cite{_grammatical_2014}.] die oben beschriebene Interaktion zwischen abstrakten und konkreten Grammatiken. Besonderes Augenmerk soll dabei auch auf den Fakt gelegt werden, dass die verschiedenen konkreten Grammatiken völlig frei voneinander ihre konkrete Sprache beschreiben können. 

Die folgenden 3 GF-Module (Zero.gf, ZeroGer.gf, ZeroChi.gf in Auflistung \ref{mj1}) ermöglichen die Übersetzung beschriebener semantischer Einheiten vom Chinesischen ins Deutsche und umgekehrt:

TODO: Störend, dass in diesem Beispiel syntaktische Cats und in Food semantische Cats (Comment, Item, Kind, Quality) verwendet werden??? Die syntaktischen Cats machen es aber sehr schön übersichtlich!

#+name: mj1
#+CAPTION[Hello-GF]: Ein erster Einblick
#+begin_src bash

abstract Zero = {            concrete ZeroGer of Zero = {    concrete ZeroChi of Zero = { 
  cat                          lincat                          lincat                      
    S; NP; VP; V2;               S, NP, VP, V2 = Str;             S, NP, VP, V2 = Str;
  fun                          lin                             lin
    Pred : NP -> VP -> S;        Pred np vp = np ++ vp;           Pred np vp = np ++ vp;
    Compl : V2 -> NP -> VP;      Compl v2 np = v2 ++ np;          Compl v2 np = v2 ++ np;
    John, Mary : NP;             John = "Johann";                 John = "约翰";
    Love : V2;                   Mary = "Marie";                  Mary = "玛丽";
                                 Love = "liebt";                  Love = "爱";
}                            }                               }
#+end_src

Testen wir zunächst diese drei Module in der GF Shell, die uns einen interaktiven Umgang mit den von uns erstellten Grammatiken ermöglicht.[fn:: Für eine ausführlichere Einführung in die Arbeit mit der Shell, siehe http://www.grammaticalframework.org/doc/tutorial/gf-tutorial.html (etwas in die Jahre gekommen, aber die grundlegenden Ausführungen zur Shell und viele weitere Dinge sind noch aktuell) sowie \cite[31]{ranta_grammatical_2011}.]

#+name: pl1
#+CAPTION[parse-lin-1]: Shell: Chin.-Deutsch
#+BEGIN_SRC bash
Languages: ZeroChi ZeroGer
Zero> parse -lang=ZeroChi "约翰 爱 玛丽" | linearize -lang=ZeroGer
Johann liebt Marie
#+END_SRC

In Zeile 1 von Auflistung \ref{pl1} sehen wir die geladenen konkreten Grammatiken, die wir für eine Übersetzung heranziehen können hinter dem Label »Languages«. Sie bilden also den Geltungsbereich (engl. scope) für die Arbeit in der Shell. Zeile 2 beginnt mit dem sogenannten Prompt, der sich aus dem Namen der geladenen abstrakten Grammatik sowie einer nach rechts ausgerichteten Spitzklammer zusammensetzt. Nach dem Prompt können wir unsere Eingaben tätigen. In der Auflistung ist die Eingabe eine Kombination von Kommandos, die eine Chinesisch-Deutsch-Übersetzung bewerkstelligt. Im einzelnen werden dafür zwei Kommandos, ~parse~ und ~linearize~, benötigt. Der genaue Ablauf sieht folgendermaßen aus:

#+ATTR_LATEX: :options [itemsep=0pt,parsep=0pt]
1. Eine Zeichenkette oder auch String (\inlst$"约翰 爱 玛丽"$) wird mittels ~parse~ eingelesen und verarbeitet.[fn:: Man beachte, dass ein String, der eingelesen werden soll, immer in Anführungszeichen eingeschlossen sein muss. Obligatorisch ist außerdem, dass die einzelen Wörter im String durch ein Leerzeichen getrennt sind. Um dies hervorzuheben wird in den Auflistungen das Leerzeichen in Strings als ␣ (U+2423, Open Box) /angedeutet/. (GF ist in erster Linie kein Werkzeug zur Tokenisierung chinesischer Sätze. Siehe auch: TODO: cf. Chinesisch-Tokenisierung-Problem.)]
2. Das Ergebnis der Verarbeitung wird durch den sog. Pipe-Operator, ~|~, weitergeleitet \ldots{}
3. \ldots{} an ~linearize~, das die Übersetzung in Zeile 3 generiert.

TODO: Wohin mit der Hilfe-Box?

\infoBox[Hilfe?]{Zu allen Kommandos ist eine Hilfe per \verb~help~ abrufbar. So liefert \inlst$help parse$ beispielsweise eine Übersicht über das \verb~parse~-Kommando.}

Sowohl ~parse~ als auch ~linearize~ kann mitgeteilt werden, welche Sprachen sie behandeln, was im Beispiel jeweils über die ~lang~-Flag geschieht: \inlst$-lang=ZeroChi$. Bleibt diese Flag unbesetzt, so werden alle Sprachen im Geltungsbereich für das Kommando benutzt.

Sehen wir uns die eben benutzten Kommandos an im einzelnen an: 
#+BEGIN_SRC bash
Zero> parse -lang=ZeroChi "约翰 爱 玛丽"
Pred John (Compl Love Mary)
#+END_SRC

~parse~ liefert hier die semantischen Einheiten unseres geparsten Satzes zurück. Die Struktur zwischen diesen Einheiten ähnelt der eines Baumes: Die Wurzel eines Baumes ist Ausgangspunkt für verschiedene Äste, die zu unterschiedlichen Blättern führen. Im obigen Fall ist die Wurzel nun ~Pred~ (die Prädikation, TODO: Hadomot Bußmann Quelle; Ziel: P. müsste meinen, einem Gegenstand Qualitäten zu oder absprechen!) von der ausgehend Äste zum Subjekt, ~John~, und zum Prädikat (~Compl~ \ldots{}) wachsen. Wir können das GF Kommando ~visualize_tree~ in Verbindung mit dem Visualisierungs-Werkzeug »Graphviz«[fn:: Siehe http://www.graphviz.com] benutzen, um uns diesen Sachverhalt zu verdeutlichen:

#+BEGIN_SRC bash
Zero> parse -lang=ZeroChi "约翰 爱 玛丽" | visualize_tree -view="firefox"
#+END_SRC

Damit sollte sich ein Programm unserer Wahl mit der PNG-Bilddatei öffnen, das uns folgenden (umgedrehten) Baum zeigt:

# :float t -> center image!
#+CAPTION[vt-1]: ~visualize\_tree~ produziert Graph mit AST (»Abstact Syntax Tree«)
#+NAME: 1-jlm
#+ATTR_LATEX: :width 0.35\textwidth :float t
[[./example-code/Zero/1-JohannesLiebtMarie.png]]


#+BEGIN_SRC bash
Zero> parse -lang=ZeroChi "约翰 爱 玛丽" | visualize_tree -view="firefox"
Pred John (Compl Love Mary)
#+END_SRC

Die Darstellungsweise der Ausgabe lässt vielleicht nicht intuitiv vermuten, dass es sich bei \inlst$Pred John (Compl Love Mary)$ um eine Art Baum handelt. 

- Angelov, 5: cat sind abstrakte syntaktische Kategorien (syntaktische Aspekt des Frameworks); sind gleichzeitig Martin Löfs basale Typen
- fun This,That,These,Those : Kind → Item; (grammatically this and that are determiners; *logically* they are functions)

- Agreement is indeed assumed to be one of the strengths of GF, so it is important to understand how it works! And not difficult, if you start with simple examples. Yours is simple enough, so let's look at it.

I have put a minimal grammar in

  http://cloud.grammaticalframework.org/gfse/

entitled "Eyes", and you can play with it and extend it as you want. The main idea is that

- NP has Number as inherent feature (field in a record)
- N has Number as variable feature (argument in a table)

Determiners set the Number of an NP, and select the number of N. Thus "this" sets an NP to be Sg, and selects the Sg form of the N.

With "your", you must think in a bit tricky way. There are, so to say, two variants of it: YourSg and YourPl. Many languages actually differentiate them (e.g. French and German) but in English they are the same string. But otherwise they work like This and These.

You should read the GF book chapter 3 for more details, and then 4 and 9 for even more details. If you don't have the book, the book slides may give enough information.


** 
** 
** 
** 
* Evaluation der chinesischen Ressourcen Grammatik
** eng_chi2.txt:
*** 把 nur auf Dinge beziehbar?
- mkUtt (mkVP answer_V2S he_NP (mkS (mkCl she_NP sleep_V))) 
to answer to him that she sleeps
把他回答说她睡 BAD 回答他说她睡了
- mkUtt (mkVP (mkVPSlash paint_V2A (mkAP black_A)))
to paint itself black
画自己黑 BAD 把它自己画黑


** Komplement des Resultats (结果补语) -- shi-de -- »Buch ist ausverkauft«?
- es scheint noch nichts dafür definiert zu sein
- versuche Satz zu bilden: "Dieses Buch ist ausverkauft"
- ~/d/n/G/l/s/chinese git:master ❯❯❯
- gf AllChi.gfo
- AllChiAbs> p "这 本 书 卖 光 " => The sentence is not complete
- tab comletion after guang -> guang hua 光滑:
LexiconChi.gf
182:smooth_A = mkA "光滑" ;

sysu/Assign_4.gf
425:glaze_V = mkV "变得光滑" ; -- 1

sysu/Assign_6.gf
27:glossy_A = mkA "光滑" ; -- 7

- Satz müsste eher mit 售完 gebildet werden! (noch nicht in RGL-Chi)
- und dann ist auch die Frage, ob shi...de dafür benutzt wird, wahrscheinlich schon: 这本书是售完的. (Beschreibung Motsch, S. 127: "Betonung der Eigenschaft des Beschriebenen"), es geht aber auch: »这本书已售完« (Shanghai Dt-Chin., 134)

** 
* End
\printbibliography
* zotero							   :noexport:
# Local Variables:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# End:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# Ende:
* Header							    :ARCHIVE: :noexport:
#+TODO: TODO | WAITING DONE
#+LATEX_CLASS: cn-article
#+TITLE: Grundlagen maschineller multilingualer Übersetzung anhand des »Grammatical Framework« (GF) mit besonderer Berücksichtigung des Hoch-Chinesischen
#+AUTHOR: René Tobner
#+LANGUAGE: de-de
#+OPTIONS: H:4 skip:nil ^:nil timestamp:nil

#+LATEX_HEADER: \usepackage[ngerman]{babel}
#+LATEX_HEADER: \addbibresource{mag.bib}

#+LATEX_HEADER: % Make commands for the quotes
#+LATEX_HEADER: \newcommand{\mq}[1]{\enquote{#1}}
#+LATEX_HEADER: \newcommand*{\openquote}{\tikz[remember picture,overlay,xshift=-15pt,yshift=-10pt]
#+LATEX_HEADER:      \node (OQ) {\quotefont\fontsize{60}{60}\selectfont``};\kern0pt}
#+LATEX_HEADER: \newcommand*{\closequote}{\tikz[remember picture,overlay,xshift=15pt,yshift=10pt]
#+LATEX_HEADER:      \node (CQ) {\quotefont\fontsize{60}{60}\selectfont''};}
#+LATEX_HEADER: % select a colour for the shading
#+LATEX_HEADER: %\definecolor{shadecolor}{named}{gray}
#+LATEX_HEADER: % wrap everything in its own environment
#+LATEX_HEADER: \newenvironment{shadequote}%
#+LATEX_HEADER: {\begin{quote}\openquote}
#+LATEX_HEADER: {\hfill\closequote\end{quote}}
#+LATEX_HEADER: 
#+LATEX_HEADER: \newcommand{\xelatex}{\XeLaTeX\xspace} 
#+LATEX_HEADER: \newcommand{\latex}{\LaTeX\xspace}
#+LATEX_HEADER: 
#+LATEX_HEADER: %\newglossary[<log-ext>]{<name>}{<in-ext>}{<out-ext>}{<title>}[<counter>]
#+LATEX_HEADER: %\newglossary[alg]{atom}{aot}{atn}{Zeichen-Ebene}
#+LATEX_HEADER: %\newglossary[slg]{sets}{sot}{stn}{Zeichensatz-Ebene}
#+LATEX_HEADER: %\newglossary[ulg]{unicode-specific}{uot}{utn}{Unicode-Spezifisches}
#+LATEX_HEADER: 
#+LATEX_HEADER: %\makeglossaries
#+LATEX_HEADER: %\loadglsentries{glossar}
#+LATEX_HEADER: % For BIBER
#+LATEX_HEADER: \DeclareSourcemap{
#+LATEX_HEADER:  \maps[datatype=bibtex, overwrite]{
#+LATEX_HEADER:    \map{
#+LATEX_HEADER:      \step[fieldset=language, null] % exclude bib language field from printing
#+LATEX_HEADER:      \step[fieldset=month, null] 
#+LATEX_HEADER:    }
#+LATEX_HEADER:  }
#+LATEX_HEADER: }
#+LATEX_HEADER: \newcommand\mpDr[1]{\marginpar{\fontspec[Scale=0.7]{Droid Sans}#1}}
#+LATEX_HEADER: \newcommand\zb{z. B.}
#+LATEX_HEADER: \newcommand\di{d. I.}
#+LATEX_HEADER: 
#+LATEX_HEADER: %Elision in citation ... took so long to find this, don't know if this the best way :(
#+LATEX_HEADER: \newcommand*\elide{\textup{[\dots]}\xspace}
#+LATEX_HEADER: % Using "[" and "]" in the pre/postnote of citation seems a big problem, therefore new command for [sic]
#+LATEX_HEADER: \newcommand*\sic{\textup{[sic]}\xspace}
#+LATEX_HEADER: 
#+LATEX_HEADER: \hyphenation{dash}
#+LATEX_HEADER: \newfontfamily\dejavus[Mapping=tex-ansi]{DejaVu Sans}
#+LATEX_HEADER: \newfontfamily\scpro[Mapping=tex-ansi]{Source Code Pro}
#+LATEX_HEADER: \newfontfamily\linmono[Mapping=tex-ansi]{Linux Libertine Mono}
#+LATEX_HEADER: \newfontfamily\linansi[Mapping=tex-ansi]{Linux Libertine}
#+LATEX_HEADER: \newcommand{\mysinglespacing}{%
#+LATEX_HEADER:   \setstretch{1}% no correction afterwards
#+LATEX_HEADER: }
#+LATEX_HEADER: \lstnewenvironment{my-inlst}{\lstset{basicstyle=\small\ttfamily\setstretch{1},language=bash}}{}
#+LATEX_HEADER:  \newcommand*{\inlst}{\lstinline[basicstyle=\small\ttfamily\setstretch{1},language=bash]}
#+LATEX_HEADER: %\newcommand{\inlst}[1]{%
#+LATEX_HEADER: %   \lstinline[basicstyle=\small\ttfamily\setstretch{1},language=bash]!#1!
#+LATEX_HEADER: %}
#+LATEX_HEADER: \newcommand{\stylst}{basicstyle=\small\ttfamily\setstretch{1}}
#+LATEX_HEADER: 
#+LATEX_HEADER: 
#+LATEX_HEADER: 
#+LATEX_HEADER: \usepackage{infobox} %thx to  https://github.com/lkiesow/thesis-latex/blob/master/tex/latex/infobox/infobox.sty              
#+LATEX_HEADER: %%%% Custom Command for floating Infoboxes
#+LATEX_HEADER: %%%% usage: \infobox{<title>}{<text>}
#+LATEX_HEADER: %\usepackage{picins} funktioniert nicht gut mit Liste (float-Umgebung) -- jetzt ohne Float mit infobox-package                
#+LATEX_HEADER: %\newcommand{\infobox}[2]{
#+LATEX_HEADER: %    \parpic(0.34\textwidth,0pt)[lf]{
#+LATEX_HEADER: %        \parbox[b]{0.32\textwidth}{
#+LATEX_HEADER: %             {\bf #1}  \small{{{#2}}}
#+LATEX_HEADER: %        }
#+LATEX_HEADER: %    }
#+LATEX_HEADER: %    \bigskip
#+LATEX_HEADER: %}

# Local Variables:
# zotero-collection: #("4" 0 1 (name "ChinGrammar"))
# End:
\pagenumbering{roman}
\listoffigures
\listoftables
